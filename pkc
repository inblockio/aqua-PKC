#!/usr/bin/env bash

set -e

if [ "$EUID" -eq 0 ]; then
    echo "Please don't run as root."
    exit 1
fi

usage() {
    cat <<'EOF'
Usage:
  pkc <command>

Options:
  --help
Commands:
  setup     Setup the system for the first time and then run the system
  stop      Gracefully stop the system
  start     Resume running the system from a stopped state
  backup    Run the system backup
  restore   Run the system restore from backup
  nuke      Destroy containers and delete backup data
EOF
}

usage_setup() {
    cat <<'EOF'
Usage:
  pkc setup [OPTIONS]

Set up a PKC instance for the first time.

Options:
  -w, --wallet-address <your crypto wallet address>
  -s, --server         <your server name; defaults to http://localhost:9352>
  --private             disable anonymous page read
  --web-public          expect --server <mediawiki.domain> --eauth-server <eauth.domain> --le-email <your@email.com>
  --empty-wiki          setup without default wiki content
  --disable-autobackup  disable MediaWiki backup service
EOF
    #  --auto-backup         expects two values <time in minutes>:<number of backups to keep>

}

check_wallet_address() {
    if [ -z "$WALLET_ADDRESS" ]; then
        echo "Error: you must specify the wallet address."
        usage_setup
        exit 1
    fi

    # https://ethereum.stackexchange.com/questions/1374/how-can-i-check-if-an-ethereum-address-is-valid
    # TODO make this address validation more comprehensive.
    if [[ ! "$WALLET_ADDRESS" =~ ^(0x)?[0-9a-fA-F]{40}$ ]]; then
        echo "Error: Your wallet address is not a valid Ethereum address."
        exit 1
    fi
}

check_dependencies() {
    local initsys

    # Check Docker installation
    if [[ ! -x "$(command -v docker)" ]]; then
        echo "Error: Docker is not yet installed. Aborting PKC installation." >&2
        exit 1
    fi

    # Check docker-compose installation
    if [[ ! -x "$(command -v docker-compose)" ]]; then
        echo "Error: docker-compose is not yet installed. Aborting PKC installation." >&2
        exit 1
    fi

    # Check git installation
    if [[ ! -x "$(command -v git)" ]]; then
        echo "Error: Git is not yet installed. Aborting PKC installation." >&2
        exit 1
    fi

    # Check Docker daemon running
    initsys=$(ps 1 | head -n 2 | tail -n 1 | awk '{print $5}')
    if [[ $initsys == *"systemd"* ]]; then
        echo "systemd init system detected. Ensuring Docker is running..."
        sudo systemctl start docker.service
    elif [[ $initsys == *"launchd"* ]]; then
        echo "launchd init system detected. Ensuring Docker is running..."
        if [[ ! "$(docker version)" == *"Engine"* ]]; then
            open /Applications/Docker.app
            echo "Waiting for Docker Desktop to start..."
        fi
        local i=1
        local sp="/-\|"
        echo -n ' '
        until [[ "$(docker version 2>/dev/null)" == *"Engine"* ]]; do
            # shellcheck disable=SC2059
            printf "\b${sp:i++%${#sp}:1}"
            sleep 1
        done
        echo ""
    fi
}

ensure_submodules() {
    # Ensure submodule dependencies are downloaded
    mkdir -p mountPoint/extensions

    # Ensure DataAccounting repo exists
    if [ ! -d ../DataAccounting ]; then
        echo "DataAccounting repo doesn't exist. Downloading..."
        # We need to do this line in a subshell so that the current directory is
        # not modified.
        (cd .. && git clone https://github.com/inblockio/DataAccounting.git)
    else
        echo "DataAccounting repo exists. But you may want to update it after this setup."
    fi

    # Ensure MediaWiki_Backup repo exists
    if [ ! -d aqua/MediaWiki_Backup ]; then
        echo "MediaWiki_Backup repo doesn't exist. Downloading..."
        (cd aqua && git clone https://github.com/inblockio/MediaWiki_Backup.git)
    else
        echo "Updating MediaWiki_Backup repo..."
        (cd aqua/MediaWiki_Backup && git pull)
    fi
    ln -sf "$PWD/aqua/MediaWiki_Backup" mountPoint/MediaWiki_Backup

    PARENTDIR="$(dirname "$PWD")"
    DEST=mountPoint/extensions/DataAccounting
    if [[ -L "$DEST" && -d "$DEST" ]]; then
        true
    else
        echo "Making a symlink for the DataAccounting repo..."
        SOURCE="$PARENTDIR/DataAccounting"
        echo "Source: $SOURCE"
        ln -sf "$SOURCE" "$DEST"
    fi

    # Download latest PKC-Content repo
    git submodule update --init --recursive --remote
}

validate_web_public_detail() {
    local pkc_server=$1
    local eauth_server=$2
    local letsencrypt_email=$3
    if [ -z "$pkc_server" ]; then
        echo "Error: You specified '--web-public' but didn't specify the MediaWiki server via '--server'"
        exit 1
    fi
    if [[ "$pkc_server" == *"https:"* ]]; then
        echo "Error: Your MediaWiki server must not contain the https scheme"
        exit 1
    fi
    if [ -z "$eauth_server" ]; then
        echo "Error: You specified '--web-public' but didn't specify the Eauth server via '--eauth-server'"
        exit 1
    fi
    if [[ "$eauth_server" == *"https:"* ]]; then
        echo "Error: Your Eauth server must not contain the https scheme"
        exit 1
    fi
    if [ -z "$letsencrypt_email" ]; then
        echo "Error: You specified '--web-public' but didn't specify the Let's Encrypt email via '--le-email'"
        exit 1
    fi
}

setup_proxy_server() {
    echo "Setting up Nginx proxy server with Let's Encrypt"
    (cd proxy_server && sudo docker-compose up -d)
    echo "Sleeping for 3s ğŸ’¤ ğŸ’¤"
    sleep 3
    echo "Proxy setup done!"
}

prepare_web_public() {
    local pkc_server=$1
    local eauth_server=$2
    local letsencrypt_email=$3
    setup_proxy_server
    echo "Applying your domain details"
    sed -i "s|MEDIAWIKI_HOST=.*|MEDIAWIKI_HOST=$pkc_server|" .env
    sed -i "s|EAUTH_HOST=.*|EAUTH_HOST=$eauth_server|" .env
    sed -i "s/LETSENCRYPT_EMAIL=.*/LETSENCRYPT_EMAIL=$letsencrypt_email/" .env
    if ! grep -q "proxy_server_net" docker-compose.yml; then
        echo "  proxy_server_net:" >>docker-compose.yml
        echo "    external: true" >>docker-compose.yml
        sed -i "s/#WEBPUBLICPLACEHOLDER/- proxy_server_net/" docker-compose.yml
    fi
}

prepare_dotenv() {
    echo '# This file is autogenerated by <pkc setup>' >.env
    cat .env.template >>.env
}

do_docker_compose_up_maybe_backup() {
    local enable_autobackup="$1"
    if "$enable_autobackup"; then
        echo "Auto-backup service is enabled."
        sudo docker-compose --profile backup up -d
    else
        echo "Auto-backup service is not enabled."
        sudo docker-compose up -d
    fi
}

run_setup() {
    local web_public=false
    local enable_autobackup=true
    while [ "$#" -gt 0 ]; do
        case "$1" in
        -h | --help)
            usage_setup
            exit 0
            ;;
        -w | --wallet-address)
            WALLET_ADDRESS="$2"
            shift
            shift
            ;;
        -s | --server)
            PKC_SERVER="$2"
            shift
            shift
            ;;
        --eauth-server)
            EAUTH_SERVER="$2"
            shift
            shift
            ;;
        --le-email)
            LETSENCRYPT_EMAIL="$2"
            shift
            shift
            ;;
        --empty-wiki)
            empty_wiki=true
            shift
            ;;
        --private)
            private=true
            shift
            ;;
        --web-public)
            web_public=true
            shift
            ;;
        --disable-autobackup)
            enable_autobackup=false
            shift
            ;;
        *) # unknown option
            usage_setup
            exit 0
            ;;
        esac
    done

    check_dependencies
    check_wallet_address
    prepare_dotenv

    if [ "$web_public" = true ]; then
        validate_web_public_detail "$PKC_SERVER" "$EAUTH_SERVER" "$LETSENCRYPT_EMAIL"
        echo "MediaWiki server name: $PKC_SERVER"
        echo "Eauth server name: $EAUTH_SERVER"
        echo "Let's Encrypt email: $LETSENCRYPT_EMAIL"
        prepare_web_public "$PKC_SERVER" "$EAUTH_SERVER" "$LETSENCRYPT_EMAIL"
        # Add https:// scheme
        PKC_SERVER="https://$PKC_SERVER"
        EAUTH_SERVER="https://$EAUTH_SERVER"
    else
        if [ -z "$PKC_SERVER" ]; then
            PKC_SERVER=http://localhost:9352
        fi
        echo "Server name: $PKC_SERVER"
    fi

    # Convert wallet address to lower case
    # This is because the address returned in Metamask API is in lower case
    WALLET_ADDRESS=$(echo "$WALLET_ADDRESS" | tr "\[A-Z\]" "\[a-z\]")

    ensure_submodules

    echo "Specifying the server name into Eauth"
    # use perl to account for cross-OS limitations of sed
    # https://stackoverflow.com/questions/4247068/sed-command-with-i-option-failing-on-mac-but-works-on-linux/14813278#14813278
    perl -i -p -e "s|PKC_SERVER|$PKC_SERVER|" .env

    echo "Executing docker-compose up -d. Be prepared to type your password."
    # Support version 1 / 2 of docker-compose
    do_docker_compose_up_maybe_backup $enable_autobackup
    # Sleep; just to be sure that the container has initialized well.
    echo "Sleeping for 10 seconds to wait for the database to be ready."
    echo "Here's an invitation to grab a â˜• or take a deep breath."
    sleep 10

    echo "Installing MediaWiki"
    # TODO split failure cases and remove || true
    sudo docker exec micro-pkc-mediawiki ./aqua/install_pkc.sh \
        --wallet-address "$WALLET_ADDRESS" \
        --pkc-server "$PKC_SERVER" \
        --eauth-server "$EAUTH_SERVER" \
        ${empty_wiki:+--empty-wiki} \
        ${private:+--private} || true

    # TODO REMOVE THIS ONCE PELITH HAS FIXED THEIR RETRY BUG
    sudo docker exec micro-pkc-eauth pkill node

    echo "Done!"
}

create_new_backup() {
    # Sort reverse chronologically and pick the most recent item. Default
    # behavior is that there is only one zip file this handles race conditions.
    sqlfile=$(docker run --rm --volumes-from micro-pkc-mediawikibackup busybox \
        sh -c 'ls -t /backup/latest/*.sql.gz | head -1' 2>/dev/null)
    imgfile=$(docker run --rm --volumes-from micro-pkc-mediawikibackup busybox \
        sh -c 'ls -t /backup/latest/*.img.tar | head -1' 2>/dev/null)

    if [[ -n "$sqlfile" && -n "$imgfile" ]]; then
        echo "Saving a copy of the most recent backup..."
        tmpdir=$(mktemp -d || exit 1)
        docker cp micro-pkc-mediawikibackup:"$sqlfile" \
            "$tmpdir/$(basename "$sqlfile")"
        docker cp micro-pkc-mediawikibackup:"$imgfile" \
            "$tmpdir/$(basename "$imgfile")"
        # Combine db archive with image tarball into single tarball
        tar -cf "backup-$(date +"%Y-%m-%d_%Hh%Mm.%A")".tar -C "$tmpdir" .
        echo "Your backup is available in the current directory."
        # Clean up the temp dir
        rm -r "$tmpdir"
    else
        echo "No recent backups found."
    fi

    echo "Starting a new MediaWiki backup!"
    echo "During backup process PKC will not be editable and login disabled."
    docker exec \
        -e DBHOST=database \
        -e DBEXCLUDE='performance_schema information_schema eauth' \
        -e USERNAME=wikiuser \
        -e SEPDIR=no \
        -e PASSWORD=example \
        -e PREBACKUP=mediawiki_backup_pre.sh \
        -w /usr/local/bin \
        micro-pkc-mediawikibackup automysqlbackup

    echo "Backup complete! You may continue using your Wiki."
}

restore_from_latest_autobackup() {
    echo "Restoring most recent backup scheduled backup..."
    if ! docker exec micro-pkc-mediawiki test -f /backup/LocalSettings.php 2>/dev/null; then
        echo "Error: MediaWiki appears to not have been installed. Please run ./pkc setup first." >&2
        return
    fi
    local latest
    latest="$(docker run --rm --volumes-from micro-pkc-mediawikibackup \
        busybox sh -c 'ls -t /backup/latest/*.sql.gz | head -1' 2>/dev/null)"
    if [ -z "$latest" ]; then
        echo "Error: No backup file found."
        return
    fi
    # TODO: Lock and unlock database when refactoring away from CC-BY upstream
    docker exec micro-pkc-database /MediaWiki_Backup/restore_database.sh "$latest"
    docker exec micro-pkc-mediawikibackup /usr/local/bin/restore_images.sh
}

if [ $# -eq 0 ]; then
    # If no argument is provided, provide info and exit early.
    usage
    exit 0
fi

# We don't use getopt because we want to support running micro-pkc on macOS.
# macOS has getopt, but it doesn't have `long` option
# See https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash
# https://unix.stackexchange.com/questions/520028/parsing-arguments-with-nested-case-statements
while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
    -h | --help)
        usage
        exit 0
        ;;
    setup)
        shift
        run_setup "$@"
        break
        ;;
    stop)
        sudo docker-compose stop
        break
        ;;
    start)
        # TODO don't hardcode starting backup service to always be true.
        do_docker_compose_up_maybe_backup true
        break
        ;;
    backup)
        create_new_backup
        break
        ;;
    restore)
        restore_from_latest_autobackup
        break
        ;;
    nuke)
        # Check we are in the micro-PKC repository
        current_repository=$(git config --get remote.origin.url)
        if [[ "$current_repository" != *"micro-PKC"* ]]; then
            echo "pkc nuke must be run from the micro-PKC directory. Aborting..."
            exit 1
        fi
        read -r -p $'Destroying containers and deleting backup data. \n\tAre you sure? ğŸ˜± [y/N] ' response
        case "$response" in
        [yY][eE][sS] | [yY])
            echo "ğŸ’¥ğŸ’¥ğŸ’¥ğŸ’¥ Kaaboooom!!!ğŸ’¥ğŸ’¥ğŸ’¥ğŸ’¥"
            # The -v flag is needed so that volumes are removed.
            set -x
            sudo docker-compose down -v
            sudo rm -r mountPoint
            set +x
            echo "ğŸœï¸ It's all gone ğŸœï¸"
            ;;
        *)
            echo "Aborting..."
            exit 0
            ;;
        esac
        break
        ;;
    *) # unknown option
        usage
        exit 0
        ;;
    esac
done
